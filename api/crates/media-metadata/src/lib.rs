// media-type-detect
//
// Copyright: 2025, Rémi Bardon <remi@remibardon.name>
// License: Mozilla Public License v2.0 (MPL v2.0)

use std::io;

#[derive(Debug, Clone, Copy)]
pub struct ImageDimensions {
    pub width: u32,
    pub height: u32,
}

pub fn parse_dimensions(
    data: impl AsRef<[u8]>,
    media_type: &media_type_detect::MediaType,
) -> io::Result<ImageDimensions> {
    match media_type_detect::is_media_type(&data, media_type) {
        Ok(true) => {}
        Ok(false) => {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                "Wrong media type",
            ));
        }
        Err(media_type_detect::UnusupportedMediaType) => {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                "Unsupported media type",
            ));
        }
    }

    let data = data.as_ref();

    match *media_type {
        "image/png" => dimensions_png(data),
        "image/jpeg" => dimensions_jpeg(data),
        "image/gif" => dimensions_gif(data),
        _ => Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            "Unsupported media type",
        )),
    }
}

/// NOTE: Code generated by Claude Sonnet 4.5 (2025-10-11).
///   If it doesn’t work, we’ll see instantly.
fn dimensions_png(data: &[u8]) -> io::Result<ImageDimensions> {
    if data.len() < 24 {
        return Err(io::Error::new(
            io::ErrorKind::InvalidData,
            "PNG data too short",
        ));
    }

    let width = u32::from_be_bytes([
        data[16], data[17], data[18], data[19],
    ]);
    let height = u32::from_be_bytes([
        data[20], data[21], data[22], data[23],
    ]);

    Ok(ImageDimensions { width, height })
}

/// NOTE: Code generated by Claude Sonnet 4.5 (2025-10-11).
///   If it doesn’t work, we’ll see instantly.
fn dimensions_gif(data: &[u8]) -> io::Result<ImageDimensions> {
    if data.len() < 10 {
        return Err(io::Error::new(
            io::ErrorKind::InvalidData,
            "GIF data too short",
        ));
    }

    let width = u16::from_le_bytes([data[6], data[7]]) as u32;
    let height = u16::from_le_bytes([data[8], data[9]]) as u32;

    Ok(ImageDimensions { width, height })
}

/// NOTE: Code generated by Claude Sonnet 4.5 (2025-10-11). I (@RemiBardon)
///   didn’t check the JPEG format specification, but we’ll see if this works
///   on the field. I know it’s a bad practice, but this is honestly so useless
///   that I won’t spend more time on it now.
fn dimensions_jpeg(data: &[u8]) -> io::Result<ImageDimensions> {
    if data.len() < 2 {
        return Err(io::Error::new(
            io::ErrorKind::InvalidData,
            "JPEG data too short",
        ));
    }

    let mut pos = 2; // Skip SOI marker (0xFFD8)

    while pos + 8 < data.len() {
        // Look for marker
        if data[pos] != 0xFF {
            pos += 1;
            continue;
        }

        let marker = data[pos + 1];

        // SOF markers: 0xC0-0xC3, 0xC5-0xC7, 0xC9-0xCB, 0xCD-0xCF
        if (0xC0 <= marker && marker <= 0xC3)
            || (0xC5 <= marker && marker <= 0xC7)
            || (0xC9 <= marker && marker <= 0xCB)
            || (0xCD <= marker && marker <= 0xCF)
        {
            if pos + 9 > data.len() {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidData,
                    "Invalid JPEG SOF marker",
                ));
            }

            let height = u16::from_be_bytes([
                data[pos + 5],
                data[pos + 6],
            ]) as u32;
            let width = u16::from_be_bytes([
                data[pos + 7],
                data[pos + 8],
            ]) as u32;

            return Ok(ImageDimensions { width, height });
        }

        // Skip this segment
        if marker == 0xD8 || marker == 0xD9 || (marker >= 0xD0 && marker <= 0xD7) {
            pos += 2;
        } else {
            if pos + 4 > data.len() {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidData,
                    "Invalid JPEG segment",
                ));
            }
            let len = u16::from_be_bytes([
                data[pos + 2],
                data[pos + 3],
            ]) as usize;
            pos += 2 + len;
        }
    }

    Err(io::Error::new(
        io::ErrorKind::InvalidData,
        "No JPEG SOF marker found",
    ))
}

#[cfg(test)]
mod tests {
    use super::*;

    /// NOTE: Test generated by Claude Sonnet 4.5 (2025-10-11) and
    ///   not checked because I (@RemiBardon) don’t really care.
    #[test]
    fn test_png_dimensions() {
        // Minimal valid PNG (1x1 red pixel)
        let png_data = vec![
            0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG signature
            0x00, 0x00, 0x00, 0x0D, // IHDR chunk size
            0x49, 0x48, 0x44, 0x52, // IHDR
            0x00, 0x00, 0x00, 0x01, // Width: 1
            0x00, 0x00, 0x00, 0x01, // Height: 1
            0x08, 0x02, 0x00, 0x00, 0x00,
        ];
        let dims = dimensions_png(&png_data).unwrap();
        assert_eq!(dims.width, 1);
        assert_eq!(dims.height, 1);
    }

    /// NOTE: Test generated by Claude Sonnet 4.5 (2025-10-11) and
    ///   not checked because I (@RemiBardon) don’t really care.
    #[test]
    fn test_gif_dimensions() {
        // Minimal GIF header (100x50)
        let gif_data = vec![
            0x47, 0x49, 0x46, 0x38, 0x39, 0x61, // "GIF89a"
            0x64, 0x00, // Width: 100 (little-endian)
            0x32, 0x00, // Height: 50 (little-endian)
        ];
        let dims = dimensions_gif(&gif_data).unwrap();
        assert_eq!(dims.width, 100);
        assert_eq!(dims.height, 50);
    }
}
