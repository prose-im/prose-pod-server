// prose-pod-server-api
//
// Copyright: 2025, Rémi Bardon <remi@remibardon.name>
// License: Mozilla Public License v2.0 (MPL v2.0)

use std::collections::HashMap;
use std::path::Path;
use std::time::{Duration, Instant};

use anyhow::Context as _;
use prosodyctl::Prosodyctl;
use tokio::task::JoinHandle;

use crate::config::AppConfig;
use crate::models::{BareJid, JidDomain, JidNode, Password};

const PROSODY_CONFIG_FILE_PATH: &'static str = "/etc/prosody/prosody.cfg.lua";

pub async fn startup(app_config: &AppConfig) -> anyhow::Result<JoinHandle<anyhow::Result<()>>> {
    let start = Instant::now();

    let prosody_config_file_path = Path::new(PROSODY_CONFIG_FILE_PATH);

    backup_prosody_conf_if_needed(prosody_config_file_path)?;

    apply_bootstrap_config(prosody_config_file_path, &app_config.server.domain)?;

    // Launch Prosody.
    let prosody = Prosodyctl::new();
    let prosody_handle = prosody.start();

    // Wait for Prosody to start.
    // TODO: Get rid of constant sleep.
    tokio::time::sleep(Duration::from_millis(100)).await;

    let mut prosodyctl = Prosodyctl::new();

    let service_accounts_credentials =
        ServiceAccountsCredentials::new(app_config.as_ref(), &app_config.server.domain);
    create_service_accounts(&mut prosodyctl, &service_accounts_credentials).await?;

    let groups = Groups::new(app_config.as_ref());
    create_groups(&mut prosodyctl, &groups, &app_config.server.domain).await?;

    add_service_accounts_to_groups(
        &mut prosodyctl,
        service_accounts_credentials
            .keys()
            .into_iter()
            .map(BareJid::node),
        groups.keys().into_iter(),
        &app_config.server.domain,
    )
    .await?;

    synchronize_rosters(
        &mut prosodyctl,
        groups.keys().into_iter(),
        &app_config.server.domain,
    )
    .await?;

    tracing::info!("Started up in {:.0?}.", start.elapsed());

    Ok(prosody_handle)
}

// MARK: Steps

fn backup_prosody_conf_if_needed(prosody_config_file_path: &Path) -> anyhow::Result<()> {
    use std::fs::File;
    use std::io::{self, Read as _};

    // Back up the Prosody configuration if it was not generated by Prose.
    // This is just to avoid a bad surprise to anyone deploying Prose on an
    // existing Prosody instance.
    match File::options().read(true).open(prosody_config_file_path) {
        Ok(mut prosody_config_file) => {
            let prose_header = "-- Prose Pod Server";
            let mut buffer = vec![0u8; prose_header.len()];

            // Read the first few bytes to check the header.
            let bytes_read = prosody_config_file
                .read(&mut buffer)
                .context("Error reading Prosody config file")?;
            buffer.truncate(bytes_read);

            if buffer != prose_header.as_bytes() {
                let mut new_path = prosody_config_file_path.to_path_buf();
                let unix_timestamp = unix_timestamp();
                new_path.set_file_name(format!("prosody.prose-backup-{unix_timestamp}.cfg.lua"));

                tracing::info!(
                    "The Prosody configuration file at <{old_path}> was not generated by Prose. \
                    To prevent data loss, it will be backed up as <{new_path}>.",
                    old_path = prosody_config_file_path.display(),
                    new_path = new_path.display(),
                )
            }

            Ok(())
        }
        Err(err) if err.kind() == io::ErrorKind::NotFound => {
            // Prosody config file does not exist already, nothing to back up.
            Ok(())
        }
        Err(err) => Err(anyhow::Error::new(err).context(format!(
            "Error opening <{path}>",
            path = prosody_config_file_path.display(),
        ))),
    }
}

fn apply_bootstrap_config(
    prosody_config_file_path: &Path,
    server_domain: &JidDomain,
) -> anyhow::Result<()> {
    use std::fs::File;
    use std::io::Write as _;

    let mut prosody_config_file = File::options()
        .write(true)
        .truncate(true)
        .create(true)
        .open(prosody_config_file_path)
        .context("Error opening Prosody config file")?;

    let bootstrap_config_template = include_str!("pod-bootstrap.cfg.lua");

    let bootstrap_config = bootstrap_config_template.replace("{{server_domain}}", server_domain);

    prosody_config_file
        .write_all(bootstrap_config.as_bytes())
        .context("Error writing Prosody config file")?;

    Ok(())
}

/// Creates the “prose-workspace” user for now, maybe more later.
async fn create_service_accounts(
    prosodyctl: &mut Prosodyctl,
    credentials: &ServiceAccountsCredentials,
) -> anyhow::Result<()> {
    // NOTE: [Prosody’s built-in roles](https://prosody.im/doc/roles#built-in-roles)
    //   don’t have a concept of non-user account. Until we have our own roles,
    //   we will create service accounts as if it were normal users.
    // TODO: Use special role for service accounts.
    let role = "prosody:member";

    for (jid, password) in credentials.iter() {
        if prosodyctl.user_exists(&jid.node(), &jid.domain()).await? {
            let summary = prosodyctl.user_password(jid, password).await?;
            tracing::info!("user_password: {summary}");

            let summary = prosodyctl.user_set_role(jid, None, role).await?;
            tracing::info!("user_set_role: {summary}");
        } else {
            let summary = prosodyctl.user_create(jid, password, Some(role)).await?;
            tracing::info!("user_create: {summary}");
        };
    }

    Ok(())
}

/// Creates the “Team” group for now, maybe more later.
async fn create_groups(
    prosodyctl: &mut Prosodyctl,
    groups: &Groups,
    server_domain: &JidDomain,
) -> anyhow::Result<()> {
    let host: &str = server_domain.as_ref();

    for (group_id, group_info) in groups.iter() {
        if !prosodyctl.groups_exists(host, group_id).await? {
            let summary = prosodyctl
                .groups_create(host, &group_info.name, None, Some(group_id))
                .await?;
            tracing::info!("groups_create: {summary}");
        }
    }

    Ok(())
}

/// Adds the “prose-workspace” user to the “Team” group for now, maybe more later.
async fn add_service_accounts_to_groups<'a, A, G>(
    prosodyctl: &mut Prosodyctl,
    service_accounts: A,
    groups: G,
    server_domain: &JidDomain,
) -> anyhow::Result<()>
where
    A: Iterator<Item = JidNode>,
    G: Iterator<Item = &'a String> + Clone,
{
    let host: &str = server_domain.as_ref();

    for ref username in service_accounts {
        for group_id in groups.clone() {
            let summary = prosodyctl
                .groups_add_member(host, group_id, username, Some(true))
                .await?;
            tracing::info!("groups_add_member: {summary}");
        }
    }

    Ok(())
}

/// Synchronizes rosters (do group subscriptions).
/// This ensures all group members are correctly subscribed.
///
/// Note that when creating groups in a previous step, most groups might have
/// been skipped because they existed already. This means the automatic
/// `do_all_group_subscriptions_by_group` might not be triggered. Since we are
/// going to do the subscriptions here anyway, we used `delay_update` there.
async fn synchronize_rosters<'a, G>(
    prosodyctl: &mut Prosodyctl,
    groups: G,
    server_domain: &JidDomain,
) -> anyhow::Result<()>
where
    G: Iterator<Item = &'a String>,
{
    let host: &str = server_domain.as_ref();

    for group_id in groups {
        let summary = prosodyctl.groups_sync(host, group_id).await?;
        tracing::info!("groups_sync: {summary}");
    }

    Ok(())
}

// MARK: Data structures

#[derive(Debug)]
#[repr(transparent)]
struct ServiceAccountsCredentials(HashMap<BareJid, Password>);

impl ServiceAccountsCredentials {
    fn new(config: &crate::config::ServiceAccountsConfig, server_domain: &JidDomain) -> Self {
        let mut data: HashMap<BareJid, Password> = HashMap::with_capacity(1);

        data.insert(
            config.prose_workspace_jid(server_domain),
            Password::random(),
        );

        Self(data)
    }
}

#[derive(Debug)]
#[repr(transparent)]
struct Groups(HashMap<String, GroupInfo>);

#[derive(Debug)]
struct GroupInfo {
    name: String,
}

impl Groups {
    fn new(config: &crate::config::TeamsConfig) -> Self {
        let mut data: HashMap<String, GroupInfo> = HashMap::with_capacity(1);

        use crate::config::TeamsConfig;
        data.insert(
            TeamsConfig::MAIN_TEAM_GROUP_ID.to_owned(),
            GroupInfo {
                name: config.main_team_name.clone(),
            },
        );

        Self(data)
    }
}

// MARK: - Helpers

fn unix_timestamp() -> u64 {
    use std::time::{Duration, SystemTime, UNIX_EPOCH};

    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or(Duration::ZERO)
        .as_secs()
}

// MARK: - Boilerplate

impl std::ops::Deref for ServiceAccountsCredentials {
    type Target = HashMap<BareJid, Password>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl std::ops::Deref for Groups {
    type Target = HashMap<String, GroupInfo>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
