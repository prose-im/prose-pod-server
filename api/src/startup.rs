// prose-pod-server-api
//
// Copyright: 2025, Rémi Bardon <remi@remibardon.name>
// License: Mozilla Public License v2.0 (MPL v2.0)

use std::collections::HashMap;
use std::path::Path;
use std::time::Duration;

use anyhow::Context as _;
use prosodyctl::Prosodyctl;
use tokio::task::JoinHandle;

use crate::config::AppConfig;
use crate::models::{BareJid, JidDomain, Password};

const PROSODY_CONFIG_FILE_PATH: &'static str = "/etc/prosody/prosody.cfg.lua";

pub async fn startup(app_config: &AppConfig) -> anyhow::Result<JoinHandle<anyhow::Result<()>>> {
    let prosody_config_file_path = Path::new(PROSODY_CONFIG_FILE_PATH);

    backup_prosody_conf_if_needed(prosody_config_file_path)?;

    apply_bootstrap_config(prosody_config_file_path)?;

    // Launch Prosody.
    let prosody = Prosodyctl::new();
    let prosody_handle = prosody.start();

    // Wait for Prosody to start.
    // TODO: Get rid of constant sleep.
    tokio::time::sleep(Duration::from_millis(100)).await;

    let mut prosodyctl = Prosodyctl::new();

    // > require"core.modulemanager".is_loaded("admin.prose.local", "admin_shell")
    // prosody> | Result: true
    // > require"core.modulemanager".is_loaded("admin.prose.local", "whatever")
    // prosody> | Result: nil
    //
    // -> Parse “Result:”

    // !! > require"core.modulemanager".load_modules_for_host("admin.prose.local")

    // > require"core.modulemanager".get_modules("example.org")
    // > require"core.modulemanager".get_modules("admin.prose.local")
    // > require"core.modulemanager".is_loaded("admin.prose.local", "groups_internal")
    // > require"core.modulemanager".get_module("admin.prose.local", "groups_internal").exists("group_id")
    // > require"core.modulemanager".get_module("error", "groups_internal").exists("group_id")
    // > require"core.modulemanager".get_module("admin.prose.local", "groups_internal").exists("team")

    // let service_accounts_credentials =
    //     ServiceAccountsCredentials::new(app_config.as_ref(), &app_config.server.domain);
    // create_service_accounts(&mut prosodyctl, &service_accounts_credentials).await?;

    // create_groups(&mut prosodyctl).await?;

    // add_service_accounts_to_groups(&mut prosodyctl).await?;

    // synchronize_rosters(&mut prosodyctl).await?;

    Ok(prosody_handle)
}

// MARK: Steps

fn backup_prosody_conf_if_needed(prosody_config_file_path: &Path) -> anyhow::Result<()> {
    use std::fs::File;
    use std::io::{self, Read as _};

    // Back up the Prosody configuration if it was not generated by Prose.
    // This is just to avoid a bad surprise to anyone deploying Prose on an
    // existing Prosody instance.
    match File::options().read(true).open(prosody_config_file_path) {
        Ok(mut prosody_config_file) => {
            let prose_header = "-- Prose Pod Server";
            let mut buffer = vec![0u8; prose_header.len()];

            // Read the first few bytes to check the header.
            let bytes_read = prosody_config_file
                .read(&mut buffer)
                .context("Error reading Prosody config file")?;
            buffer.truncate(bytes_read);

            if buffer != prose_header.as_bytes() {
                let mut new_path = prosody_config_file_path.to_path_buf();
                let unix_timestamp = unix_timestamp();
                new_path.set_file_name(format!("prosody.prose-backup-{unix_timestamp}.cfg.lua"));

                tracing::info!(
                    "The Prosody configuration file at <{old_path}> was not generated by Prose. \
                    To prevent data loss, it will be backed up as <{new_path}>.",
                    old_path = prosody_config_file_path.display(),
                    new_path = new_path.display(),
                )
            }

            Ok(())
        }
        Err(err) if err.kind() == io::ErrorKind::NotFound => {
            // Prosody config file does not exist already, nothing to back up.
            Ok(())
        }
        Err(err) => Err(anyhow::Error::new(err).context(format!(
            "Error opening <{path}>",
            path = prosody_config_file_path.display(),
        ))),
    }
}

fn apply_bootstrap_config(prosody_config_file_path: &Path) -> anyhow::Result<()> {
    use std::fs::File;
    use std::io::Write as _;

    let mut prosody_config_file = File::options()
        .write(true)
        .truncate(true)
        .create(true)
        .open(prosody_config_file_path)
        .context("Error opening Prosody config file")?;

    prosody_config_file
        .write_all(include_str!("pod-bootstrap.cfg.lua").as_bytes())
        .context("Error writing Prosody config file")?;

    Ok(())
}

/// Creates the “prose-workspace” user for now, maybe more later.
async fn create_service_accounts(
    prosodyctl: &mut Prosodyctl,
    credentials: &ServiceAccountsCredentials,
) -> anyhow::Result<()> {
    // NOTE: [Prosody’s built-in roles](https://prosody.im/doc/roles#built-in-roles)
    //   don’t have a concept of non-user account. Until we have our own roles,
    //   we will create service accounts as if it were normal users.
    // TODO: Use special role for service accounts.
    let role = Some("prosody:member");

    for (jid, password) in credentials.iter() {
        let summary = prosodyctl.user_create(jid, password, role).await?;
        tracing::info!("{summary}");
    }

    Ok(())
}

/// Creates the “Team” group for now, maybe more later.
async fn create_groups(prosodyctl: &mut Prosodyctl) -> anyhow::Result<()> {
    // TODO: Test if exists before creation
    todo!()
}

/// Adds the “prose-workspace” user to the “Team” group for now, maybe more later.
async fn add_service_accounts_to_groups(prosodyctl: &mut Prosodyctl) -> anyhow::Result<()> {
    todo!()
}

/// Synchronizes rosters (do group subscriptions).
/// This ensures all group members are correctly subscribed.
///
/// Note that when creating groups in a previous step, most groups might have
/// been skipped because they existed already. This means the automatic
/// `do_all_group_subscriptions_by_group` might not be triggered. Since we are
/// going to do the subscriptions here anyway, we used `delay_update` there.
async fn synchronize_rosters(prosodyctl: &mut Prosodyctl) -> anyhow::Result<()> {
    // - Synchronize rosters (if not already done by mod_auth_internal)
    todo!()
}

// MARK: Data structures

#[derive(Debug)]
#[repr(transparent)]
struct ServiceAccountsCredentials(HashMap<BareJid, Password>);

impl ServiceAccountsCredentials {
    fn new(config: &crate::config::ServiceAccountsConfig, server_domain: &JidDomain) -> Self {
        let mut data: HashMap<BareJid, Password> = HashMap::with_capacity(1);
        data.insert(
            config.prose_workspace_jid(server_domain),
            Password::random(),
        );

        Self(data)
    }
}

// MARK: - Helpers

fn unix_timestamp() -> u64 {
    use std::time::{Duration, SystemTime, UNIX_EPOCH};

    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or(Duration::ZERO)
        .as_secs()
}

// MARK: - Boilerplate

impl std::ops::Deref for ServiceAccountsCredentials {
    type Target = HashMap<BareJid, Password>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
