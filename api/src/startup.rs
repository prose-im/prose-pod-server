// prose-pod-server-api
//
// Copyright: 2025, RÃ©mi Bardon <remi@remibardon.name>
// License: Mozilla Public License v2.0 (MPL v2.0)

use std::{
    fs::File,
    io::{self, Read, Write},
    path::{Path, PathBuf},
    time::Duration,
};

use anyhow::Context as _;
use prosodyctl::Prosodyctl;
use tokio::task::JoinHandle;

const PROSODY_CONFIG_FILE_PATH: &'static str = "/etc/prosody/prosody.cfg.lua";

pub async fn startup() -> anyhow::Result<JoinHandle<anyhow::Result<()>>> {
    let prosody_config_file_path = Path::new(PROSODY_CONFIG_FILE_PATH);
    // Back up the Prosody configuration if it was not generated by Prose.
    // This is just to avoid a bad surprise to anyone deploying Prose on an
    // existing Prosody instance.
    match File::options().read(true).open(prosody_config_file_path) {
        Ok(mut prosody_config_file) => {
            let prose_header = "-- Prose Pod Server";
            let mut buffer = vec![0u8; prose_header.len()];

            // Read the first few bytes to check the header.
            let bytes_read = prosody_config_file
                .read(&mut buffer)
                .context("Error reading Prosody config file")?;
            buffer.truncate(bytes_read);

            if buffer != prose_header.as_bytes() {
                let mut new_path: PathBuf = prosody_config_file_path.to_path_buf();
                let unix_timestamp = unix_timestamp();
                new_path.set_file_name(format!("prosody.prose-backup-{unix_timestamp}.cfg.lua"));

                tracing::info!(
                    "The Prosody configuration file at <{old_path}> was not generated by Prose. To prevent data loss, it will be backed up as <{new_path}>.",
                    old_path = prosody_config_file_path.display(),
                    new_path = new_path.display(),
                )
            }
        }
        Err(err) if err.kind() == io::ErrorKind::NotFound => {
            // Prosody config file does not exist already, nothing to back up.
        }
        Err(err) => {
            return Err(anyhow::Error::new(err).context(format!(
                "Error opening <{path}>",
                path = prosody_config_file_path.display(),
            )));
        }
    }

    let mut prosody_config_file = File::options()
        .write(true)
        .truncate(true)
        .create(true)
        .open(prosody_config_file_path)
        .context("Error opening Prosody config file")?;

    prosody_config_file
        .write_all(include_str!("pod-bootstrap.cfg.lua").as_bytes())
        .context("Error writing Prosody config file")?;

    // Launch Prosody.
    let prosody = Prosodyctl::new();
    let prosody_handle = prosody.start();

    // Wait for Prosody to start.
    tokio::time::sleep(Duration::from_millis(100)).await;

    let mut prosodyctl = Prosodyctl::new();

    {
        let hostname = "admin.prose.local";
        let res = prosodyctl
            .list_users(hostname)
            .await
            .context("Error running `user:list`")?;
        tracing::debug!("user:list => {res:?}");
    }
    {
        let jid = "test@admin.prose.local";
        let password = "password";
        let res = prosodyctl
            .create_user(jid, password)
            .await
            .context("Error running `user:create`")?;
        tracing::debug!("user:create => {res:?}");
    }
    {
        let jid = "test@admin.prose.local";
        let password = "password";
        let res = prosodyctl
            .create_user(jid, password)
            .await
            .context("Error running `user:create`")
            .expect_err("Should conflict");
        tracing::debug!("user:create => {res:?}");
    }
    {
        let jid = "test@admin.prose.local";
        let res = prosodyctl
            .delete_user(jid)
            .await
            .context("Error running `user:delete`")?;
        tracing::debug!("user:delete => {res:?}");
    }
    {
        let hostname = "admin.prose.local";
        let res = prosodyctl
            .list_users(hostname)
            .await
            .context("Error running `user:list`")?;
        tracing::debug!("user:list => {res:?}");
    }
    {
        let jid = "test@admin.prose.local";
        let password = "password";
        let res = prosodyctl
            .create_user(jid, password)
            .await
            .context("Error running `user:create`")?;
        tracing::debug!("user:create => {res:?}");
    }
    {
        let hostname = "admin.prose.local";
        let res = prosodyctl
            .list_users(hostname)
            .await
            .context("Error running `user:list`")?;
        tracing::debug!("user:list => {res:?}");
    }

    drop(prosodyctl);

    tokio::time::sleep(Duration::from_secs(3)).await;

    let mut prosodyctl = Prosodyctl::new();

    {
        let hostname = "admin.prose.local";
        let res = prosodyctl
            .list_users(hostname)
            .await
            .context("Error running `user:list`")?;
        tracing::debug!("user:list => {res:?}");
    }

    Ok(prosody_handle)
}

// MARK: - Helpers

fn unix_timestamp() -> u64 {
    use std::time::{Duration, SystemTime, UNIX_EPOCH};

    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or(Duration::ZERO)
        .as_secs()
}
